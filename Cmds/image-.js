/**
 * Commande /image - G√©n√©ration d'images IA avec Gemini (Pollinations en fallback)
 * @param {string} senderId - ID de l'utilisateur
 * @param {string} args - Description de l'image √† g√©n√©rer
 * @param {object} ctx - Contexte partag√© du bot
 */
const { GoogleGenerativeAI } = require("@google/generative-ai");

// Configuration Gemini
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

module.exports = async function cmdImage(senderId, args, ctx) {
    const { addToMemory, getRandomInt, log } = ctx;
    
    if (!args.trim()) {
        return `üé® OH OUI ! Je peux g√©n√©rer des images magnifiques ! ‚ú®
üñºÔ∏è /image [ta description] - Je cr√©e ton image de r√™ve !
üé® /image chat robot mignon - Exemple adorable
üå∏ /image paysage f√©erique coucher soleil - Exemple po√©tique
‚ö° /image random - Une surprise image !
üíï Je suis super dou√©e pour cr√©er des images ! D√©cris-moi ton r√™ve et je le dessine pour toi !
üé≠ Tous les styles : r√©aliste, cartoon, anime, artistique...
üí° Plus tu me donnes de d√©tails, plus ton image sera parfaite !
‚ùì Besoin d'aide ? Tape /help pour voir toutes mes capacit√©s ! üåü`;
    }
    
    let prompt = args.trim();
    const senderIdStr = String(senderId);
    
    // Images al√©atoires si demand√©
    if (prompt.toLowerCase() === "random") {
        const randomPrompts = [
            "beautiful fairy garden with sparkling flowers and butterflies",
            "cute magical unicorn in enchanted forest with rainbow",
            "adorable robot princess with jeweled crown in castle",
            "dreamy space goddess floating among stars and galaxies",
            "magical mermaid palace underwater with pearl decorations",
            "sweet vintage tea party with pastel colors and roses",
            "cozy cottagecore house with flower gardens and sunshine",
            "elegant anime girl with flowing dress in cherry blossoms",
            "mystical dragon soaring through aurora borealis",
            "cyberpunk city with neon lights and flying cars"
        ];
        prompt = randomPrompts[Math.floor(Math.random() * randomPrompts.length)];
    }
    
    // Valider le prompt
    if (prompt.length < 3) {
        return "‚ùå Oh l√† l√† ! Ta description est un peu courte ! Donne-moi au moins 3 lettres pour que je puisse cr√©er quelque chose de beau ! üíï";
    }
    
    if (prompt.length > 200) {
        return "‚ùå Oups ! Ta description est trop longue ! Maximum 200 caract√®res s'il te pla√Æt ! üå∏";
    }
    
    // Optimiser le prompt pour de meilleurs r√©sultats
    const optimizedPrompt = optimizePromptForImageGeneration(prompt);
    
    try {
        // ‚úÖ PRIORIT√â: Essayer d'abord avec Gemini 2.0 Flash Image Generation
        log.info(`üé® Tentative g√©n√©ration Gemini pour ${senderId}: ${prompt}`);
        
        const imageResult = await generateWithGemini(optimizedPrompt, log);
        
        if (imageResult && imageResult.success) {
            // Sauvegarder dans la m√©moire
            addToMemory(senderIdStr, 'user', `Image demand√©e: ${prompt}`);
            addToMemory(senderIdStr, 'assistant', `Image g√©n√©r√©e par Gemini: ${prompt}`);
            
            log.info(`üíé Image Gemini g√©n√©r√©e avec succ√®s pour ${senderId}`);
            
            return {
                type: "image",
                url: imageResult.imageUrl,
                caption: `üé® Tadaaa ! Image cr√©√©e par Gemini AI ! ‚ú®

üìù "${prompt}"
ü§ñ G√©n√©r√©e par..
üéØ Style: ${imageResult.style || 'Auto-d√©tect√©'}

üíï J'esp√®re qu'elle te pla√Æt ! Tape /image pour une nouvelle cr√©ation ! üåü`
            };
        }
        
        throw new Error('Gemini image generation failed');
        
    } catch (geminiError) {
        log.warning(`‚ö†Ô∏è Gemini image √©chec pour ${senderId}: ${geminiError.message}`);
        
        try {
            // ‚úÖ FALLBACK: Utiliser Pollinations si Gemini √©choue
            log.info(`üîÑ Fallback Pollinations pour ${senderId}`);
            
            const pollinationsResult = await generateWithPollinations(optimizedPrompt, getRandomInt);
            
            if (pollinationsResult && pollinationsResult.success) {
                // Sauvegarder dans la m√©moire
                addToMemory(senderIdStr, 'user', `Image demand√©e: ${prompt}`);
                addToMemory(senderIdStr, 'assistant', `Image g√©n√©r√©e par Pollinations: ${prompt}`);
                
                log.info(`üå∏ Image Pollinations g√©n√©r√©e avec succ√®s pour ${senderId}`);
                
                return {
                    type: "image",
                    url: pollinationsResult.imageUrl,
                    caption: `üé® Tadaaa ! Voici ton image cr√©√©e avec amour ! ‚ú®

üìù "${prompt}"
üî¢ Seed magique: ${pollinationsResult.seed}
ü§ñ G√©n√©r√©e.

üíï J'esp√®re qu'elle te pla√Æt ! Tape /image pour une nouvelle cr√©ation ! üåü`
                };
            }
            
            throw new Error('Pollinations generation also failed');
            
        } catch (pollinationsError) {
            log.error(`‚ùå Erreur totale g√©n√©ration image ${senderId}: Gemini(${geminiError.message}) + Pollinations(${pollinationsError.message})`);
            
            return `üé® Oh non ! Mes ateliers artistiques rencontrent une petite difficult√© ! üòÖ
üîß Ni mon pinceau Gemini ni mon crayon Pollinations ne fonctionnent pour le moment
‚è∞ R√©essaie dans quelques secondes, mes outils magiques vont revenir !
üé≤ Ou essaie /image random pour une surprise diff√©rente !
‚ùì Tape /help si tu as besoin d'aide ! üíñ`;
        }
    }
};

// ‚úÖ G√©n√©ration avec Gemini 2.0 Flash Image Generation
async function generateWithGemini(prompt, log) {
    try {
        // Configuration sp√©ciale pour la g√©n√©ration d'images
        const model = genAI.getGenerativeModel({ 
            model: "gemini-2.0-flash-preview-image-generation"
        });
        
        // Prompt optimis√© pour la g√©n√©ration d'images
        const imagePrompt = `Generate an image: ${prompt}`;
        
        // Utiliser la m√©thode sp√©cifique pour les images
        const result = await model.generateContent({
            contents: [
                {
                    role: "user",
                    parts: [
                        {
                            text: imagePrompt
                        }
                    ]
                }
            ],
            generationConfig: {
                maxOutputTokens: 1024,
                temperature: 0.7,
                topP: 0.8,
                topK: 40
            }
        });
        
        // Traitement de la r√©ponse image
        const response = await result.response;
        
        // M√©thode 1: V√©rifier les candidates
        if (response.candidates && response.candidates.length > 0) {
            const candidate = response.candidates[0];
            
            if (candidate.content && candidate.content.parts) {
                for (const part of candidate.content.parts) {
                    // Chercher les donn√©es inline
                    if (part.inlineData && part.inlineData.data) {
                        const mimeType = part.inlineData.mimeType || 'image/png';
                        const base64Data = part.inlineData.data;
                        const imageUrl = `data:${mimeType};base64,${base64Data}`;
                        
                        log.info(`‚úÖ Image Gemini g√©n√©r√©e avec succ√®s (inline data)`);
                        return {
                            success: true,
                            imageUrl: imageUrl,
                            style: 'Gemini AI Generated'
                        };
                    }
                    
                    // Chercher les blobs de donn√©es
                    if (part.fileData && part.fileData.fileUri) {
                        log.info(`‚úÖ Image Gemini g√©n√©r√©e avec succ√®s (file URI)`);
                        return {
                            success: true,
                            imageUrl: part.fileData.fileUri,
                            style: 'Gemini AI Generated'
                        };
                    }
                }
            }
        }
        
        // M√©thode 2: V√©rifier directement dans la r√©ponse
        if (response.data) {
            const imageUrl = `data:image/png;base64,${response.data}`;
            log.info(`‚úÖ Image Gemini g√©n√©r√©e avec succ√®s (response data)`);
            return {
                success: true,
                imageUrl: imageUrl,
                style: 'Gemini AI Generated'
            };
        }
        
        // Si aucune image n'est trouv√©e
        log.warning(`‚ö†Ô∏è Aucune donn√©e image trouv√©e dans la r√©ponse Gemini`);
        throw new Error('No image data found in Gemini response');
        
    } catch (error) {
        // Log d√©taill√© pour debugging
        if (error.message.includes('response modalities')) {
            log.error(`‚ùå Erreur modalit√© Gemini: Le mod√®le ne supporte pas cette configuration`);
        } else if (error.message.includes('400')) {
            log.error(`‚ùå Erreur requ√™te Gemini (400): ${error.message}`);
        } else {
            log.error(`‚ùå Erreur g√©n√©rale Gemini image: ${error.message}`);
        }
        
        return { success: false, error: error.message };
    }
}

// ‚úÖ G√©n√©ration avec Pollinations (fallback)
async function generateWithPollinations(prompt, getRandomInt) {
    try {
        // Encoder le prompt pour l'URL
        const encodedPrompt = encodeURIComponent(prompt);
        
        // G√©n√©rer avec des param√®tres optimis√©s
        const seed = getRandomInt(100000, 999999);
        const imageUrl = `https://image.pollinations.ai/prompt/${encodedPrompt}?width=768&height=768&seed=${seed}&enhance=true&nologo=true&model=flux`;
        
        return {
            success: true,
            imageUrl: imageUrl,
            seed: seed
        };
        
    } catch (error) {
        return { success: false, error: error.message };
    }
}

// ‚úÖ Optimisation du prompt pour de meilleurs r√©sultats
function optimizePromptForImageGeneration(prompt) {
    // Nettoyer le prompt
    let optimized = prompt.trim();
    
    // Ajouter des mots-cl√©s pour am√©liorer la qualit√© si n√©cessaire
    const qualityKeywords = ['high quality', 'detailed', 'beautiful', 'artistic'];
    const hasQualityKeyword = qualityKeywords.some(keyword => 
        optimized.toLowerCase().includes(keyword)
    );
    
    if (!hasQualityKeyword && optimized.length < 150) {
        optimized += ', high quality, detailed, beautiful';
    }
    
    // Remplacer certains mots fran√ßais par leurs √©quivalents anglais pour de meilleurs r√©sultats
    const translations = {
        'chat': 'cat',
        'chien': 'dog',
        'paysage': 'landscape',
        'portrait': 'portrait',
        'maison': 'house',
        'voiture': 'car',
        'fleur': 'flower',
        'arbre': 'tree'
    };
    
    for (const [french, english] of Object.entries(translations)) {
        const regex = new RegExp(`\\b${french}\\b`, 'gi');
        optimized = optimized.replace(regex, english);
    }
    
    return optimized;
}
