/**
 * NakamaBot - Commande Admin /autoreply
 * R√©pond automatiquement aux commentaires non r√©pondus sur la page Facebook
 * avec l'IA (Gemini + Mistral) en respectant les restrictions Facebook
 * 
 * Usage: /autoreply [start|stop|status|config]
 * @param {string} senderId - ID de l'administrateur
 * @param {string} args - Arguments de la commande
 * @param {object} ctx - Contexte partag√© du bot
 */

const axios = require('axios');

// ========================================
// üîß CONFIGURATION
// ========================================

const ADMIN_IDS = (process.env.ADMIN_IDS || '').split(',').map(id => id.trim());
const PAGE_ACCESS_TOKEN = process.env.PAGE_ACCESS_TOKEN;
const PAGE_ID = process.env.PAGE_ID;

// Configuration Auto-Reply
const AUTO_REPLY_CONFIG = {
    enabled: false,
    intervalMinutes: 10, // V√©rifier toutes les 10 minutes
    maxCommentsPerRun: 5, // Maximum 5 commentaires par run
    responseDelay: 3000, // 3 secondes entre chaque r√©ponse
    maxCommentAge: 24, // R√©pondre aux commentaires de max 24h
    skipIfReplied: true, // Skip si d√©j√† une r√©ponse
    personality: 'friendly', // friendly, professional, enthusiastic
};

// √âtat global
let autoReplyInterval = null;
const processedComments = new Set();
const PROCESSED_CACHE_TTL = 86400000; // 24 heures

// Restrictions Facebook √† respecter
const FACEBOOK_RESTRICTIONS = {
    maxMessageLength: 8000, // Facebook limite √† 8000 chars
    rateLimit: {
        commentsPerHour: 100, // Limite safe
        repliesPerMinute: 10
    },
    bannedContent: [
        'spam', 'porn', 'hate', 'violence', 'illegal',
        'scam', 'phishing', 'malware'
    ],
    requiredCompliance: true
};

// ========================================
// üîê V√âRIFICATION ADMIN
// ========================================

function isAdmin(senderId) {
    return ADMIN_IDS.includes(String(senderId));
}

// ========================================
// üìä R√âCUP√âRATION COMMENTAIRES NON R√âPONDUS
// ========================================

async function getUnrepliedComments(log) {
    try {
        if (!PAGE_ACCESS_TOKEN || !PAGE_ID) {
            throw new Error('PAGE_ACCESS_TOKEN ou PAGE_ID non configur√©');
        }

        // R√©cup√©rer les posts r√©cents de la page
        const postsResponse = await axios.get(
            `https://graph.facebook.com/v21.0/${PAGE_ID}/posts`,
            {
                params: {
                    access_token: PAGE_ACCESS_TOKEN,
                    fields: 'id,message,created_time',
                    limit: 10 // 10 posts les plus r√©cents
                }
            }
        );

        if (!postsResponse.data.data || postsResponse.data.data.length === 0) {
            log.info('üì≠ Aucun post r√©cent trouv√©');
            return [];
        }

        const unrepliedComments = [];
        const now = Date.now();
        const maxAge = AUTO_REPLY_CONFIG.maxCommentAge * 3600000; // Heures en ms

        // Pour chaque post, r√©cup√©rer les commentaires
        for (const post of postsResponse.data.data) {
            try {
                const commentsResponse = await axios.get(
                    `https://graph.facebook.com/v21.0/${post.id}/comments`,
                    {
                        params: {
                            access_token: PAGE_ACCESS_TOKEN,
                            fields: 'id,from,message,created_time,comment_count',
                            limit: 50,
                            filter: 'stream' // Tous les commentaires
                        }
                    }
                );

                if (commentsResponse.data.data) {
                    for (const comment of commentsResponse.data.data) {
                        const commentAge = now - new Date(comment.created_time).getTime();
                        
                        // Filtres
                        if (commentAge > maxAge) continue; // Trop vieux
                        if (processedComments.has(comment.id)) continue; // D√©j√† trait√©
                        if (comment.from.id === PAGE_ID) continue; // C'est la page elle-m√™me
                        
                        // V√©rifier si d√©j√† une r√©ponse
                        if (AUTO_REPLY_CONFIG.skipIfReplied && comment.comment_count > 0) {
                            continue;
                        }

                        unrepliedComments.push({
                            id: comment.id,
                            postId: post.id,
                            postMessage: post.message || '',
                            from: comment.from,
                            message: comment.message,
                            createdTime: comment.created_time,
                            age: commentAge
                        });
                    }
                }

                // Petit d√©lai entre chaque post pour √©viter rate limit
                await new Promise(resolve => setTimeout(resolve, 500));

            } catch (error) {
                log.warning(`‚ö†Ô∏è Erreur r√©cup√©ration commentaires post ${post.id}: ${error.message}`);
            }
        }

        log.info(`üìä ${unrepliedComments.length} commentaires non r√©pondus trouv√©s`);
        return unrepliedComments.slice(0, AUTO_REPLY_CONFIG.maxCommentsPerRun);

    } catch (error) {
        log.error(`‚ùå Erreur getUnrepliedComments: ${error.message}`);
        return [];
    }
}

// ========================================
// ü§ñ G√âN√âRATION R√âPONSE IA
// ========================================

async function generateAIReply(comment, ctx) {
    const { log, callMistralAPI } = ctx;
    const { callGeminiWithRotation, checkIfAllGeminiKeysDead } = require('./chat');

    try {
        const personalityPrompts = {
            friendly: "Tu es une IA sympathique et chaleureuse qui repr√©sente NakamaBot. Ton ton est amical et positif.",
            professional: "Tu es une IA professionnelle qui repr√©sente NakamaBot. Ton ton est courtois et informatif.",
            enthusiastic: "Tu es une IA enthousiaste qui repr√©sente NakamaBot. Ton ton est dynamique et encourageant."
        };

        const personality = personalityPrompts[AUTO_REPLY_CONFIG.personality] || personalityPrompts.friendly;

        const prompt = `${personality}

CONTEXTE POST:
"${comment.postMessage.substring(0, 300)}"

COMMENTAIRE DE ${comment.from.name}:
"${comment.message}"

INSTRUCTIONS CRITIQUES:
‚úÖ R√©ponds au commentaire de mani√®re naturelle et pertinente
‚úÖ Sois concis (max 500 caract√®res)
‚úÖ Utilise quelques emojis avec parcimonie
‚úÖ Adapte-toi au ton du commentaire
‚úÖ Si c'est une question, r√©ponds directement
‚úÖ Si c'est un compliment, remercie chaleureusement
‚úÖ Si c'est une critique constructive, montre de l'empathy
‚úÖ NE mentionne JAMAIS que tu es une IA ou un bot
‚úÖ NE parle PAS de recherches ou sources

‚ùå RESTRICTIONS FACEBOOK (TR√àS IMPORTANT):
- AUCUN contenu spam, haineux, violent, sexuel, ill√©gal
- AUCUN lien suspect ou non autoris√©
- AUCUNE demande d'informations personnelles
- AUCUN contenu commercial agressif
- AUCUNE d√©sinformation

Si le commentaire est inappropri√©, r√©ponds: "Merci pour ton commentaire ! üí´"

R√âPONSE NATURELLE (max 500 chars):`;

        let response;

        // Essayer Gemini d'abord
        if (!checkIfAllGeminiKeysDead()) {
            try {
                response = await callGeminiWithRotation(prompt);
                log.info(`üíé R√©ponse g√©n√©r√©e via Gemini`);
            } catch (geminiError) {
                log.warning(`‚ö†Ô∏è Gemini √©chec: ${geminiError.message}`);
            }
        }

        // Fallback Mistral
        if (!response) {
            const messages = [
                { role: "system", content: personality },
                { role: "user", content: prompt }
            ];
            response = await callMistralAPI(messages, 500, 0.7);
            log.info(`üîÑ R√©ponse g√©n√©r√©e via Mistral`);
        }

        if (!response) {
            throw new Error('Aucune IA disponible');
        }

        // Nettoyage et validation
        let cleanResponse = response.trim();
        
        // Limiter √† 500 caract√®res pour s√©curit√©
        if (cleanResponse.length > 500) {
            cleanResponse = cleanResponse.substring(0, 497) + '...';
        }

        // V√©rifier contenu banni
        const lowerResponse = cleanResponse.toLowerCase();
        for (const banned of FACEBOOK_RESTRICTIONS.bannedContent) {
            if (lowerResponse.includes(banned)) {
                log.warning(`‚ö†Ô∏è Contenu banni d√©tect√©: ${banned}`);
                return "Merci pour ton commentaire ! üí´";
            }
        }

        return cleanResponse;

    } catch (error) {
        log.error(`‚ùå Erreur generateAIReply: ${error.message}`);
        return "Merci pour ton commentaire ! üí´";
    }
}

// ========================================
// üì§ ENVOI R√âPONSE FACEBOOK
// ========================================

async function postReplyToComment(commentId, replyMessage, log) {
    try {
        if (!PAGE_ACCESS_TOKEN) {
            throw new Error('PAGE_ACCESS_TOKEN non configur√©');
        }

        // V√©rifier longueur
        if (replyMessage.length > FACEBOOK_RESTRICTIONS.maxMessageLength) {
            replyMessage = replyMessage.substring(0, FACEBOOK_RESTRICTIONS.maxMessageLength - 3) + '...';
        }

        const response = await axios.post(
            `https://graph.facebook.com/v21.0/${commentId}/comments`,
            {
                message: replyMessage
            },
            {
                params: {
                    access_token: PAGE_ACCESS_TOKEN
                }
            }
        );

        if (response.data && response.data.id) {
            log.info(`‚úÖ R√©ponse post√©e avec succ√®s: ${response.data.id}`);
            processedComments.add(commentId);
            return { success: true, replyId: response.data.id };
        }

        throw new Error('R√©ponse invalide de Facebook');

    } catch (error) {
        if (error.response) {
            log.error(`‚ùå Erreur Facebook API: ${error.response.data.error?.message || error.message}`);
        } else {
            log.error(`‚ùå Erreur postReply: ${error.message}`);
        }
        return { success: false, error: error.message };
    }
}

// ========================================
// üîÑ PROCESSUS AUTO-REPLY
// ========================================

async function runAutoReplyProcess(ctx) {
    const { log } = ctx;

    try {
        log.info(`ü§ñ D√©marrage processus auto-reply...`);

        const unrepliedComments = await getUnrepliedComments(log);

        if (unrepliedComments.length === 0) {
            log.info(`‚úÖ Aucun commentaire √† traiter`);
            return { processed: 0, success: 0, errors: 0 };
        }

        let successCount = 0;
        let errorCount = 0;

        for (const comment of unrepliedComments) {
            try {
                log.info(`üí¨ Traitement commentaire de ${comment.from.name}: "${comment.message.substring(0, 50)}..."`);

                // G√©n√©rer r√©ponse IA
                const aiReply = await generateAIReply(comment, ctx);
                
                log.info(`ü§ñ R√©ponse g√©n√©r√©e: "${aiReply.substring(0, 50)}..."`);

                // Poster la r√©ponse
                const result = await postReplyToComment(comment.id, aiReply, log);

                if (result.success) {
                    successCount++;
                    log.info(`‚úÖ R√©ponse post√©e avec succ√®s`);
                } else {
                    errorCount++;
                    log.error(`‚ùå √âchec post r√©ponse`);
                }

                // D√©lai entre chaque r√©ponse pour respecter rate limit
                await new Promise(resolve => setTimeout(resolve, AUTO_REPLY_CONFIG.responseDelay));

            } catch (error) {
                errorCount++;
                log.error(`‚ùå Erreur traitement commentaire ${comment.id}: ${error.message}`);
            }
        }

        log.info(`üìä Processus termin√©: ${successCount} succ√®s, ${errorCount} erreurs`);

        return {
            processed: unrepliedComments.length,
            success: successCount,
            errors: errorCount
        };

    } catch (error) {
        log.error(`‚ùå Erreur critique runAutoReplyProcess: ${error.message}`);
        return { processed: 0, success: 0, errors: 1 };
    }
}

// ========================================
// üéõÔ∏è GESTION AUTO-REPLY
// ========================================

function startAutoReply(ctx) {
    const { log } = ctx;

    if (autoReplyInterval) {
        return { success: false, message: "Auto-reply d√©j√† actif" };
    }

    AUTO_REPLY_CONFIG.enabled = true;

    // Ex√©cution imm√©diate
    runAutoReplyProcess(ctx);

    // Puis toutes les X minutes
    autoReplyInterval = setInterval(() => {
        runAutoReplyProcess(ctx);
    }, AUTO_REPLY_CONFIG.intervalMinutes * 60000);

    log.info(`‚úÖ Auto-reply d√©marr√© (intervalle: ${AUTO_REPLY_CONFIG.intervalMinutes} min)`);

    return {
        success: true,
        message: `ü§ñ Auto-reply activ√© !\n\n‚è±Ô∏è Intervalle: ${AUTO_REPLY_CONFIG.intervalMinutes} minutes\nüìä Max commentaires/run: ${AUTO_REPLY_CONFIG.maxCommentsPerRun}\nüé≠ Personnalit√©: ${AUTO_REPLY_CONFIG.personality}`
    };
}

function stopAutoReply(log) {
    if (!autoReplyInterval) {
        return { success: false, message: "Auto-reply d√©j√† inactif" };
    }

    clearInterval(autoReplyInterval);
    autoReplyInterval = null;
    AUTO_REPLY_CONFIG.enabled = false;

    log.info(`üõë Auto-reply arr√™t√©`);

    return {
        success: true,
        message: "üõë Auto-reply d√©sactiv√© avec succ√®s"
    };
}

function getAutoReplyStatus() {
    return {
        enabled: AUTO_REPLY_CONFIG.enabled,
        intervalMinutes: AUTO_REPLY_CONFIG.intervalMinutes,
        maxCommentsPerRun: AUTO_REPLY_CONFIG.maxCommentsPerRun,
        personality: AUTO_REPLY_CONFIG.personality,
        processedCount: processedComments.size
    };
}

// ========================================
// üõ°Ô∏è COMMANDE PRINCIPALE
// ========================================

module.exports = async function cmdAutoReply(senderId, args, ctx) {
    const { log, sendMessage } = ctx;

    // V√©rification admin
    if (!isAdmin(senderId)) {
        log.warning(`üö´ Acc√®s refus√© pour ${senderId} (non admin)`);
        return "üö´ Cette commande est r√©serv√©e aux administrateurs.";
    }

    const command = args.trim().toLowerCase().split(' ')[0] || 'status';

    try {
        switch (command) {
            case 'start': {
                const result = startAutoReply(ctx);
                return result.message;
            }

            case 'stop': {
                const result = stopAutoReply(log);
                return result.message;
            }

            case 'status': {
                const status = getAutoReplyStatus();
                return `üìä ùó¶ùòÅùóÆùòÅùòÇùòÅ ùóîùòÇùòÅùóº-ùó•ùó≤ùóΩùóπùòÜ

${status.enabled ? '‚úÖ ùóîùóñùóßùóúùóô' : 'üõë ùóúùó°ùóîùóñùóßùóúùóô'}

‚öôÔ∏è ùóñùóºùóªùó≥ùó∂ùó¥ùòÇùóøùóÆùòÅùó∂ùóºùóª:
‚Ä¢ Intervalle: ${status.intervalMinutes} minutes
‚Ä¢ Max commentaires/run: ${status.maxCommentsPerRun}
‚Ä¢ Personnalit√©: ${status.personality}
‚Ä¢ Commentaires trait√©s: ${status.processedCount}

üéÆ ùóñùóºùó∫ùó∫ùóÆùóªùó±ùó≤ùòÄ:
‚Ä¢ /autoreply start - D√©marrer
‚Ä¢ /autoreply stop - Arr√™ter
‚Ä¢ /autoreply config - Configuration
‚Ä¢ /autoreply test - Test manuel

üìã ùó•ùó≤ùòÄùòÅùóøùó∂ùó∞ùòÅùó∂ùóºùóªùòÄ ùóôùóÆùó∞ùó≤ùóØùóºùóºùó∏:
‚úÖ Conforme API Facebook
‚úÖ Rate limiting respect√©
‚úÖ Contenu filtr√©`;
            }

            case 'config': {
                return `‚öôÔ∏è ùóñùóºùóªùó≥ùó∂ùó¥ùòÇùóøùóÆùòÅùó∂ùóºùóª ùóîùòÇùòÅùóº-ùó•ùó≤ùóΩùóπùòÜ

üìä ùó£ùóÆùóøùóÆùó∫√®ùòÅùóøùó≤ùòÄ:
‚Ä¢ intervalMinutes: ${AUTO_REPLY_CONFIG.intervalMinutes}
‚Ä¢ maxCommentsPerRun: ${AUTO_REPLY_CONFIG.maxCommentsPerRun}
‚Ä¢ responseDelay: ${AUTO_REPLY_CONFIG.responseDelay}ms
‚Ä¢ maxCommentAge: ${AUTO_REPLY_CONFIG.maxCommentAge}h
‚Ä¢ personality: ${AUTO_REPLY_CONFIG.personality}

üé≠ ùó£ùó≤ùóøùòÄùóºùóªùóªùóÆùóπùó∂ùòÅ√©ùòÄ ùó±ùó∂ùòÄùóΩùóºùóªùó∂ùóØùóπùó≤ùòÄ:
‚Ä¢ friendly (par d√©faut)
‚Ä¢ professional
‚Ä¢ enthusiastic

üîß Pour modifier: √©diter AUTO_REPLY_CONFIG dans le code`;
            }

            case 'test': {
                log.info(`üß™ Test manuel auto-reply par ${senderId}`);
                await sendMessage(senderId, "üß™ Test en cours...");
                
                const result = await runAutoReplyProcess(ctx);
                
                return `üß™ ùóßùó≤ùòÄùòÅ ùóßùó≤ùóøùó∫ùó∂ùóª√©

üìä ùó•√©ùòÄùòÇùóπùòÅùóÆùòÅùòÄ:
‚Ä¢ Commentaires trait√©s: ${result.processed}
‚Ä¢ Succ√®s: ${result.success}
‚Ä¢ Erreurs: ${result.errors}

${result.success > 0 ? '‚úÖ Auto-reply fonctionne !' : '‚ö†Ô∏è Aucun commentaire trait√©'}`;
            }

            default: {
                return `ü§ñ ùóîùòÇùòÅùóº-ùó•ùó≤ùóΩùóπùòÜ - ùóîùó±ùó∫ùó∂ùóª

R√©pond automatiquement aux commentaires non r√©pondus sur la page Facebook.

üéÆ ùóñùóºùó∫ùó∫ùóÆùóªùó±ùó≤ùòÄ:
‚Ä¢ /autoreply start - Activer auto-reply
‚Ä¢ /autoreply stop - D√©sactiver auto-reply
‚Ä¢ /autoreply status - Voir le statut
‚Ä¢ /autoreply config - Voir la config
‚Ä¢ /autoreply test - Test manuel

‚ú® ùóôùóºùóªùó∞ùòÅùó∂ùóºùóªùóªùóÆùóπùó∂ùòÅ√©ùòÄ:
‚úÖ R√©ponses IA intelligentes (Gemini + Mistral)
‚úÖ Filtrage contenu inappropri√©
‚úÖ Respect rate limits Facebook
‚úÖ Personnalit√©s adaptables
‚úÖ Historique des commentaires trait√©s

‚ö†Ô∏è N√©cessite: PAGE_ACCESS_TOKEN et PAGE_ID configur√©s`;
            }
        }

    } catch (error) {
        log.error(`‚ùå Erreur cmdAutoReply: ${error.message}`);
        return `‚ùå Erreur: ${error.message}`;
    }
};

// ========================================
// üßπ NETTOYAGE P√âRIODIQUE
// ========================================

// Nettoyer le cache toutes les 24h
setInterval(() => {
    const now = Date.now();
    processedComments.forEach(commentId => {
        // Supprimer les commentaires trait√©s il y a plus de 24h
        // Note: Id√©alement, stocker avec timestamp pour nettoyage pr√©cis
        if (processedComments.size > 1000) {
            processedComments.clear();
        }
    });
}, 86400000); // 24 heures

// ========================================
// üì§ EXPORTS
// ========================================

module.exports.startAutoReply = startAutoReply;
module.exports.stopAutoReply = stopAutoReply;
module.exports.getAutoReplyStatus = getAutoReplyStatus;
module.exports.runAutoReplyProcess = runAutoReplyProcess;
module.exports.AUTO_REPLY_CONFIG = AUTO_REPLY_CONFIG;
